"""
Merge engine.

This module applies user selections to a diff tree (`DiffNode`) and produces a
single merged JSON-compatible Python object.

The merge process is driven by a diff tree generated by the diff builder.
Each node in the tree corresponds to a canonical path and contains per-document
presence/value information plus child nodes for containers.

Core ideas
----------
- Selections are provided as a mapping: path -> Selection.
- Selections inherit down the tree: selecting a document at a subtree path acts
  as a default for all descendants unless overridden by a more specific path.
- Object nodes merge by keys (children), array nodes merge by element children.
- Selecting a document where a node is missing deletes that node in the output.
- Leaf nodes with status `same` or `missing` can be auto-resolved safely.
- Leaf nodes with status `diff` or `type_error` require a selection; otherwise
  they are reported as unresolved merge conflicts.

Payload note
------------
The diff tree intentionally does not embed full container values (object/array)
in `ValuePresence.value`. Merging therefore relies on recursively merging child
nodes for containers rather than copying container values directly.

Paths
-----
Paths must match the diff builder's canonical format:
- object keys: "a.b.c"
- arrays: "steps[0].name"
- root: ""
"""

from __future__ import annotations

from typing import Any

from diff_fuse.models.diff import DiffNode, DiffStatus, NodeKind, ValuePresence
from diff_fuse.models.merge import MergeSelection

# Sentinel used internally to represent "deleted / not present in merged output".
_MISSING = object()


class MergeConflictError(RuntimeError):
    """
    Raised when merge cannot proceed due to unresolved diffs/type errors.

    Parameters
    ----------
    unresolved_paths : list[str]
        Canonical paths that remain unresolved because no selection was provided
        (directly or via inheritance) for a conflicting leaf.

    Attributes
    ----------
    unresolved_paths : list[str]
        Paths that require explicit resolution.
    """

    def __init__(self, unresolved_paths: list[str]) -> None:
        msg = "Unresolved merge conflicts at: " + ", ".join(unresolved_paths)
        super().__init__(msg)
        self.unresolved_paths = unresolved_paths


def _dedupe_preserve_order(paths: list[str]) -> list[str]:
    """
    De-duplicate paths while preserving their first-seen order.

    Parameters
    ----------
    paths : list[str]
        Input paths.

    Returns
    -------
    list[str]
        De-duplicated paths in stable order.
    """
    seen: set[str] = set()
    out: list[str] = []
    for p in paths:
        if p not in seen:
            seen.add(p)
            out.append(p)
    return out


def _pick_present_value(node: DiffNode) -> Any:
    """
    Pick a present value from any document for a node.

    This is only safe when a node is known to be auto-resolvable (status is
    `same` or `missing`). For containers, `ValuePresence.value` is typically
    None, so callers should only use this for scalar leaves unless they
    explicitly accept that limitation.

    Parameters
    ----------
    node : DiffNode
        Diff node to inspect.

    Returns
    -------
    Any
        The first present value encountered, or `_MISSING` if none are present.

    Example
    -------
    For a node with per_doc:
    {
        "a": ValuePresence(present=True, value=5, value_type="number"),
        "b": ValuePresence(present=True, value=5, value_type="number"),
        "c": ValuePresence(present=False, value=None, value_type=None),
    }
    This returns 5 (from doc "a") since it's present, even though "c" is missing.
    """
    for vp in node.per_doc.values():
        if vp.present:
            return vp.value
    return _MISSING


def _value_for_doc(node: DiffNode, doc_id: str) -> Any:
    """
    Get the selected document's value for a node.

    Parameters
    ----------
    node : DiffNode
        Node to read.
    doc_id : str
        Document identifier.

    Returns
    -------
    Any
        Value for the document at this node, or `_MISSING` if the node is absent
        in that document.

    Notes
    -----
    Container nodes intentionally do not embed values in the diff response, so
    this often returns None for objects/arrays even when present. The merge
    algorithm therefore resolves containers by recursion, not by copying.
    """
    vp: ValuePresence | None = node.per_doc.get(doc_id)
    if vp is None or not vp.present:
        return _MISSING
    return vp.value


def _effective_selection(
    node: DiffNode,
    selections: dict[str, MergeSelection],
    inherited: MergeSelection | None,
) -> MergeSelection | None:
    """
    Determine the selection active at a node.

    Exact path matches override inherited selections.

    Parameters
    ----------
    node : DiffNode
        Current node.
    selections : dict[str, MergeSelection]
        User selections.
    inherited : MergeSelection | None
        Selection inherited from the nearest ancestor path (if any).

    Returns
    -------
    MergeSelection | None
        The effective selection at this node.

    Example
    -------
    Given selections:
    - "a": doc "A"
    - "a.b.c": doc "B"
    Then:
    - node "a" has effective selection doc "A"
    - node "a.b" has effective selection doc "A" (inherited)
    - node "a.b.c" has effective selection doc "B" (overrides parent)
    - node "a.b.c.d" has effective selection doc "B" (inherits from "a.b.c")
    """
    return selections.get(node.path, inherited)


def _merge_object_children(
    node: DiffNode,
    selections: dict[str, MergeSelection],
    inherited: MergeSelection | None,
    unresolved: list[str],
) -> Any:
    """
    Merge an object node by merging its children.

    Parameters
    ----------
    node : DiffNode
        Object node.
    selections : dict[str, MergeSelection]
        User selections.
    inherited : MergeSelection | None
        Selection inherited for this subtree.
    unresolved : list[str]
        Accumulator for unresolved conflict paths.

    Returns
    -------
    Any
        A dict representing the merged object, or `_MISSING` if the object does
        not exist in any document (i.e., absent everywhere).

    Example
    -------
    For an object node with children "x" and "y", this recursively merges "x"
    and "y" and returns a dict like {"x": merged_x, "y": merged_y}, omitting keys that resolve to `_MISSING`.
    """
    out: dict[str, Any] = {}
    for child in node.children:
        merged_child = _merge_node(child, selections, inherited, unresolved)
        if merged_child is not _MISSING:
            assert child.key is not None
            out[child.key] = merged_child

    node_exists_somewhere = any(vp.present for vp in node.per_doc.values())
    return out if node_exists_somewhere else _MISSING


def _merge_array_children(
    node: DiffNode,
    selections: dict[str, MergeSelection],
    inherited: MergeSelection | None,
    unresolved: list[str],
) -> Any:
    """
    Merge an array node by merging its element children.

    Parameters
    ----------
    node : DiffNode
        Array node.
    selections : dict[str, MergeSelection]
        User selections.
    inherited : MergeSelection | None
        Selection inherited for this subtree.
    unresolved : list[str]
        Accumulator for unresolved conflict paths.

    Returns
    -------
    Any
        A list representing the merged array, or `_MISSING` if the array does
        not exist in any document (i.e., absent everywhere).

    Notes
    -----
    The diff builder aligns array elements according to a configured strategy.
    This function assumes children already reflect that alignment.

    Example
    -------
    For an array node with children representing elements at indices 0, 1, and 2,
    this recursively merges those children and returns a list like [merged_0, merged_1, merged_2].
    """
    out_list: list[Any] = []
    for child in node.children:
        merged_child = _merge_node(child, selections, inherited, unresolved)
        if merged_child is not _MISSING:
            out_list.append(merged_child)

    node_exists_somewhere = any(vp.present for vp in node.per_doc.values())
    return out_list if node_exists_somewhere else _MISSING


def _apply_selection_to_node(
    node: DiffNode,
    sel: MergeSelection,
    selections: dict[str, MergeSelection],
    unresolved: list[str],
) -> Any:
    """
    Apply a selection to a node.

    Manual selections always produce a value and stop recursion.
    Document selections either delete the node (if missing in the chosen doc),
    or act as an inherited default for containers so deeper overrides remain
    possible.

    Parameters
    ----------
    node : DiffNode
        Current node.
    sel : MergeSelection
        Effective selection at this node.
    selections : dict[str, MergeSelection]
        All user selections.
    unresolved : list[str]
        Accumulator for unresolved conflict paths.

    Returns
    -------
    Any
        Merged value for the node, or `_MISSING` if deleted.

    Example
    -------
    For a node with path "a.b.c" and selection doc "A", this picks the value
    from doc "A" at that node. If the node is an object and doc "A" doesn't exist at that path,
    this returns `_MISSING` (i.e., the node is deleted). If the node is an object and doc "A"
    does exist, this recursively merges children with doc "A" as the inherited selection,
    allowing for deeper manual overrides.
    """
    if sel.kind == "manual":
        return sel.manual_value

    # doc selection
    assert sel.doc_id is not None
    chosen = _value_for_doc(node, sel.doc_id)
    if chosen is _MISSING:
        # Selecting a doc where this node doesn't exist deletes it.
        return _MISSING

    # For containers, treat doc selection as a default for subtree so leaf overrides still work.
    if node.kind == NodeKind.object and node.children:
        return _merge_object_children(node, selections, inherited=sel, unresolved=unresolved)

    if node.kind == NodeKind.array and node.children:
        return _merge_array_children(node, selections, inherited=sel, unresolved=unresolved)

    # Leaf node: select value directly.
    return chosen


def _merge_node(
    node: DiffNode,
    selections: dict[str, MergeSelection],
    inherited: MergeSelection | None,
    unresolved: list[str],
) -> Any:
    """
    Merge a single node recursively.

    Parameters
    ----------
    node : DiffNode
        Node to merge.
    selections : dict[str, MergeSelection]
        User selections.
    inherited : MergeSelection | None
        Selection inherited from an ancestor subtree, if any.
    unresolved : list[str]
        Accumulator for unresolved conflict paths.

    Returns
    -------
    Any
        Merged value for the node, or `_MISSING` if the node is deleted.

    Example
    -------
    For a node with path "a.b.c", this determines the effective selection at that path
    (e.g., doc "A" from "a.b.c" or inherited doc "A" from "a.b"), applies it, and returns the merged value.
    If no selection is active, this returns `_MISSING`. For an object node with no selection, this recursively
    merges children and returns a dict. For an array node with no selection, this recursively merges children
    and returns a list.
    """
    sel = _effective_selection(node, selections, inherited)

    if sel is not None:
        return _apply_selection_to_node(node, sel, selections, unresolved)

    # No selection active: containers are merged by recursion (even if status is diff).
    if node.kind == NodeKind.object and node.children:
        return _merge_object_children(node, selections, inherited=None, unresolved=unresolved)

    if node.kind == NodeKind.array and node.children:
        return _merge_array_children(node, selections, inherited=None, unresolved=unresolved)

    # Leaf auto-resolve if safe.
    if node.status in (DiffStatus.same, DiffStatus.missing):
        return _pick_present_value(node)

    # Conflicting leaf without selection.
    unresolved.append(node.path)
    return _MISSING


def merge_from_diff_tree(
    root: DiffNode,
    selections: dict[str, MergeSelection],
    *,
    raise_on_conflict: bool = True,
) -> Any:
    """
    Merge documents according to selections, producing a single JSON object.

    Parameters
    ----------
    root : DiffNode
        Root node of the diff tree.
    selections : dict[str, MergeSelection]
        Map of canonical path -> merge selection describing how to resolve that path.
        Merge selections inherit down the tree: a selection at "a.b" applies to all
        descendants unless overridden by a more specific path.
    raise_on_conflict : bool, default=True
        If True, raise `MergeConflictError` when unresolved conflict paths exist.
        If False, return a best-effort partial merge and leave unresolved paths
        omitted (deleted) from the output.

    Returns
    -------
    Any
        Merged JSON-compatible Python structure.

    Raises
    ------
    MergeConflictError
        If `raise_on_conflict=True` and unresolved conflicts exist.

    Notes
    -----
    - Unresolved conflicts are identified at the smallest unresolved nodes,
      typically scalar leaves and array element leaves.
    - Nodes resolved to `_MISSING` are omitted from parent objects/arrays.
    - If the entire root resolves to `_MISSING`, an empty object `{}` is returned
      as a stable API-friendly default.
    """
    unresolved: list[str] = []

    merged = _merge_node(root, selections, inherited=None, unresolved=unresolved)

    if unresolved:
        unresolved = _dedupe_preserve_order(unresolved)
        if raise_on_conflict:
            raise MergeConflictError(unresolved)

    return {} if merged is _MISSING else merged


def try_merge_from_diff_tree(
    root: DiffNode,
    selections: dict[str, MergeSelection],
) -> tuple[Any, list[str]]:
    """
    Best-effort merge that never raises.

    Parameters
    ----------
    root : DiffNode
        Root node of the diff tree.

    selections : dict[str, MergeSelection]
        User merge selections.

    Returns
    -------
    tuple[Any, list[str]]
        (merged_output, unresolved_paths)

        - merged_output is the best-effort merged JSON structure.
        - unresolved_paths lists canonical paths that still require resolution.

    Notes
    -----
    This helper is convenient for API endpoints that want to always return a
    payload while still reporting unresolved conflicts to the client.
    """
    try:
        merged = merge_from_diff_tree(root, selections, raise_on_conflict=True)
        return merged, []
    except MergeConflictError as e:
        merged = merge_from_diff_tree(root, selections, raise_on_conflict=False)
        return merged, e.unresolved_paths
