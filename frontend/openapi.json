{"openapi":"3.1.0","info":{"title":"diff-fuse","version":"0.1.0"},"paths":{"/":{"post":{"summary":"Create","description":"Create a new session.\n\nThis endpoint stores the provided documents server-side and returns\na `session_id` that can be used for subsequent operations such as:\n\n- diff computation\n- merge resolution\n- array key suggestions\n- export\n\nParameters\n----------\nreq : AddDocsSessionRequest\n    Session creation payload containing the input documents.\n\nReturns\n-------\nSessionResponse\n    Contains the generated `session_id` and document metadata.\n\nNotes\n-----\n- Document parsing errors (if any) are captured in the stored\n  `DocumentResult` objects and surfaced in later operations.","operationId":"create__post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/AddDocsSessionRequest"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/SessionResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/{session_id}/add-docs":{"post":{"summary":"Add Docs","description":"Add documents to an existing session.\n\nThis endpoint allows clients to append new documents to an existing\nsession. The new documents are parsed, normalized, and stored\nalongside the existing ones.\n\nParameters\n----------\nsession_id : str\n    Target session identifier.\nreq : AddDocsSessionRequest\n    Request payload containing the new documents to add.\n\nReturns\n-------\nSessionResponse\n    Updated session metadata after adding the new documents.\n\nNotes\n-----\nThis operation mutates the session by appending new documents. The\nexisting documents remain unchanged.","operationId":"add_docs__session_id__add_docs_post","parameters":[{"name":"session_id","in":"path","required":true,"schema":{"type":"string","title":"Session Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/AddDocsSessionRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/SessionResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/{session_id}/remove-doc":{"post":{"summary":"Remove Doc","description":"Remove a document from an existing session.\n\nThis endpoint allows clients to remove a specific document from an\nexisting session by its `doc_id`. The session's stored documents are\nupdated accordingly.\n\nParameters\n----------\nsession_id : str\n    Target session identifier.\nreq : RemoveDocSessionRequest\n    Request payload containing the `doc_id` of the document to remove.\n\nReturns\n-------\nSessionResponse\n    Updated session metadata after removing the specified document.\n\nNotes\n-----\n- This operation mutates the session by removing the specified document. The\nremaining documents remain unchanged.","operationId":"remove_doc__session_id__remove_doc_post","parameters":[{"name":"session_id","in":"path","required":true,"schema":{"type":"string","title":"Session Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/RemoveDocSessionRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/SessionResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/{session_id}/docs-meta":{"get":{"summary":"List Docs Meta","description":"List metadata for all documents in a session.\n\nParameters\n----------\nsession_id : str\n    Target session identifier.\n\nReturns\n-------\nSessionResponse\n    Session metadata including document metadata for all documents in the session.","operationId":"list_docs_meta__session_id__docs_meta_get","parameters":[{"name":"session_id","in":"path","required":true,"schema":{"type":"string","title":"Session Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/SessionResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/{session_id}/diff":{"post":{"summary":"Diff","description":"Compute the diff tree for a session.\n\nThis endpoint builds a structural diff across all documents stored in\nthe specified session. The result is a hierarchical tree of `DiffNode`\nobjects that the UI can render side-by-side.\n\nParameters\n----------\nsession_id : str\n    Identifier of the session containing the documents to compare.\nreq : DiffRequest\n    Diff configuration payload, containing per-array\n    matching strategies.\n\nReturns\n-------\nDiffResponse\n    The computed diff tree rooted at the document root.\n\nRaises\n------\nDomainError\n    If the session does not exist or has expired.\n\nNotes\n-----\n- The diff is recomputed on each call using cached normalized documents.\n- Array handling behavior depends on `array_strategies`.\n- The returned tree uses stable canonical paths suitable for UI state.","operationId":"diff__session_id__diff_post","parameters":[{"name":"session_id","in":"path","required":true,"schema":{"type":"string","title":"Session Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/DiffRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DiffResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/{session_id}/merge":{"post":{"summary":"Merge","description":"Produce a merged document for a session.\n\nThis endpoint applies the provided path selections to the session's\ndocuments and returns the synthesized merged output. Any unresolved\nconflicts are reported explicitly.\n\nParameters\n----------\nsession_id : str\n    Identifier of the session containing the documents to merge.\nreq : MergeRequest\n    Merge configuration including:\n    - diff configuration (array strategies)\n    - per-path merge selections\n\nReturns\n-------\nMergeResponse\n    The merged document along with any unresolved conflict paths.\n\nRaises\n------\nDomainError\n    If the session does not exist or has expired.\n\nNotes\n-----\n- Merge behavior is deterministic given the same selections.\n- Container nodes inherit selections down the tree unless overridden.\n- Paths listed in `unresolved_paths` require user intervention.","operationId":"merge__session_id__merge_post","parameters":[{"name":"session_id","in":"path","required":true,"schema":{"type":"string","title":"Session Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/MergeRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/MergeResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/{session_id}/arrays/suggest-keys":{"post":{"summary":"Suggest Keys","description":"Suggest candidate key fields for an array node within a session.\n\nThis endpoint analyzes the array located at the provided canonical path\nacross all session documents and returns ranked key candidates that may\nbe suitable for keyed array matching.\n\nParameters\n----------\nsession_id : str\n    Identifier of the session containing the documents to analyze.\nreq : SuggestArrayKeysRequest\n    Request containing:\n    - `path`: canonical path to the target array node\n    - `top_k`: maximum number of suggestions to return\n\nReturns\n-------\nSuggestArrayKeysResponse\n    Ranked list of suggested key fields with scoring metadata.\n\nRaises\n------\nDomainError\n    If the session does not exist or has expired.\nInvalidPath\n    If the provided path is malformed or unsupported.\n\nNotes\n-----\n- Only arrays of objects are meaningful for key suggestion.\n- Documents that fail parsing are ignored for suggestion purposes.\n- Suggestions are heuristic and should be treated as guidance,\n  not guarantees of uniqueness.","operationId":"suggest_keys__session_id__arrays_suggest_keys_post","parameters":[{"name":"session_id","in":"path","required":true,"schema":{"type":"string","title":"Session Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/SuggestArrayKeysRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/SuggestArrayKeysResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/{session_id}/export/text":{"post":{"summary":"Export Text","description":"Return the merged document as formatted text.\n\nThis endpoint is primarily intended for UI workflows such as:\n- copy-to-clipboard\n- inline preview\n- quick inspection of merge results\n\nParameters\n----------\nsession_id : str\n    Identifier of the session containing the documents to merge.\nreq : ExportRequest\n    Export configuration including:\n    - merge request (diff config + selections)\n    - pretty-print preference\n    - conflict requirements\n\nReturns\n-------\nExportTextResponse\n    Textual representation of the merged JSON along with any unresolved\n    conflict paths.\n\nRaises\n------\nDomainError\n    If the session does not exist or has expired.","operationId":"export_text__session_id__export_text_post","parameters":[{"name":"session_id","in":"path","required":true,"schema":{"type":"string","title":"Session Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExportRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExportTextResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/{session_id}/export/download":{"post":{"summary":"Export Download","description":"Download the merged document as a JSON file.\n\nThis endpoint returns the merged result as an HTTP attachment suitable\nfor saving to disk.\n\nParameters\n----------\nsession_id : str\n    Identifier of the session containing the documents to merge.\nreq : ExportRequest\n    Export configuration controlling merge behavior and formatting.\n\nReturns\n-------\nResponse\n    Binary HTTP response with:\n    - media type: application/json\n    - content-disposition: attachment\n    - body: UTF-8 encoded JSON\n\nRaises\n------\nDomainError\n    If the session does not exist or has expired.\n\nNotes\n-----\nThe downloaded JSON is identical to the text export output, aside from\ntransport encoding.","operationId":"export_download__session_id__export_download_post","parameters":[{"name":"session_id","in":"path","required":true,"schema":{"type":"string","title":"Session Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExportRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/health":{"get":{"summary":"Health","description":"Health check endpoint.\n\nReturns\n-------\ndict[str, str]\n    Minimal health payload. Intended for load balancers and orchestration checks.","operationId":"health_health_get","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"additionalProperties":{"type":"string"},"type":"object","title":"Response Health Health Get"}}}}}}}},"components":{"schemas":{"AddDocsSessionRequest":{"properties":{"documents":{"items":{"$ref":"#/components/schemas/InputDocument"},"type":"array","minItems":1,"title":"Documents"}},"additionalProperties":false,"type":"object","required":["documents"],"title":"AddDocsSessionRequest","description":"Request payload for creating a new session\nor adding documents to an existing session.\n\nA session stores the provided documents server-side and returns a\n``session_id`` that can be used to compute diffs, apply merges,\nrequest array key suggestions, and export results without resending\ndocument content.\n\nAttributes\n----------\ndocuments : list[InputDocument]\n    The set of input documents to store in the session.\n    Constraints:\n    - Must contain at least one document (N-way comparisons, N â‰¥ 1).\n    - Each document must include a stable ``doc_id`` that the client\n      will later reference in merge selections.\n\nNotes\n-----\nDocuments are parsed and normalized during session creation so that\nsubsequent operations can reuse cached results efficiently."},"ArrayMeta":{"properties":{"strategy":{"$ref":"#/components/schemas/ArrayStrategy"}},"additionalProperties":false,"type":"object","required":["strategy"],"title":"ArrayMeta","description":"Extra metadata attached to array nodes.\n\nAttributes\n----------\nstrategy : ArrayStrategy\n    The effective array strategy applied at this array node.\n\nNotes\n-----\nThis is only included when `DiffNode.kind == NodeKind.array`."},"ArrayStrategy":{"properties":{"mode":{"$ref":"#/components/schemas/ArrayStrategyMode","default":"index"},"key":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Key","description":"Object field used for keyed matching (mode=keyed)."},"similarity_threshold":{"anyOf":[{"type":"number","maximum":1.0,"minimum":0.0},{"type":"null"}],"title":"Similarity Threshold","description":"Similarity threshold in [0.0, 1.0] (mode=similarity)."}},"additionalProperties":false,"type":"object","title":"ArrayStrategy","description":"Per-array matching configuration.\n\nThis model controls how a specific array path should be aligned during\ndiff computation.\n\nAttributes\n----------\nmode : ArrayStrategyMode\n    Matching strategy to apply.\n\nkey : str | None\n    Object field used for keyed matching (required when\n    ``mode=\"keyed\"``).\n    Example:\n    - ``\"id\"``\n    - ``\"name\"``\nsimilarity_threshold : float | None\n    Threshold used by the similarity matcher (future feature).\n    Must lie in the closed interval ``[0.0, 1.0]``.\n\nNotes\n-----\nIf a strategy is invalid for the actual data (e.g., keyed mode on\nnon-object arrays), the diff engine will surface an error\nat the corresponding array node."},"ArrayStrategyMode":{"type":"string","enum":["index","keyed","similarity"],"title":"ArrayStrategyMode","description":"Array element matching strategy.\n\nAttributes\n----------\nindex : str\n    Match elements by positional index.\n    Example:\n    ``arr[0]`` aligns across all documents.\nkeyed : str\n    Match elements by a key field inside each object element.\n    Requirements:\n    - Elements must be JSON objects.\n    - The configured key must exist in each element.\n    - Key values should be unique (per document).\nsimilarity : str\n    Match elements using a similarity heuristic (planned feature)."},"DiffNode":{"properties":{"path":{"type":"string","title":"Path","description":"Canonical path like 'a.b[0].c'. Root is ''."},"key":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Key","description":"Last path segment (object key or array element label). Root uses None."},"kind":{"$ref":"#/components/schemas/NodeKind"},"status":{"$ref":"#/components/schemas/DiffStatus"},"message":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Message","description":"Explanation for type errors or strategy failures."},"per_doc":{"additionalProperties":{"$ref":"#/components/schemas/ValuePresence"},"type":"object","title":"Per Doc","description":"Map doc_id -> presence/value at this node/path."},"children":{"items":{"$ref":"#/components/schemas/DiffNode"},"type":"array","title":"Children"},"array_meta":{"anyOf":[{"$ref":"#/components/schemas/ArrayMeta"},{"type":"null"}]}},"additionalProperties":false,"type":"object","required":["path","kind","status","per_doc"],"title":"DiffNode","description":"Node in the diff tree.\n\nEach node corresponds to a canonical path and describes:\n- structural kind (scalar/object/array)\n- diff status (same/diff/missing/type_error)\n- per-document presence/value information\n- child nodes for object/array structures\n\nAttributes\n----------\npath : str\n    Canonical path identifier (e.g., ``\"a.b[0].c\"``). The root path is ``\"\"``.\nkey : str | None\n    Final segment of the path used for UI presentation.\n    - object child -> object key\n    - array child  -> array group label\n    - root         -> None\nkind : NodeKind\n    Structural kind of the node.\nstatus : DiffStatus\n    Diff status of the node.\nmessage : str | None\n    Optional explanation, typically used when `status == \"type_error\"`.\n    Example messages:\n    - ``\"type mismatch at 'x': number vs string\"``\n    - ``\"Keyed mode requires 'key' at array path 'items'\"``\nper_doc : dict[str, ValuePresence]\n    Mapping from ``doc_id`` to per-document presence/value information at this path.\nchildren : list[DiffNode]\n    Child nodes for object and array nodes.\n    Ordering guarantees:\n    - Object children are sorted by object key.\n    - Array children ordering depends on the applied array strategy (e.g., index\n      ascending or stable keyed ordering).\narray_meta : ArrayMeta | None\n    Present only for array nodes, to surface array strategy configuration.\n\nNotes\n-----\n- `path` values are unique within the tree and can be used as stable identifiers\n  for selections and UI state.\n- Container nodes generally omit embedded values in `per_doc[*].value`."},"DiffRequest":{"properties":{"array_strategies":{"additionalProperties":{"$ref":"#/components/schemas/ArrayStrategy"},"type":"object","title":"Array Strategies"}},"additionalProperties":false,"type":"object","title":"DiffRequest","description":"Request payload for computing a diff within a session.\n\nAttributes\n----------\narray_strategies : dict[str, ArrayStrategy]\n    Optional per-path overrides controlling how arrays are matched.\n    Keys are canonical array paths (e.g., ``\"steps\"`` or\n    ``\"pipeline.tasks\"``).\n    Behavior:\n    - Missing paths use the backend default strategy.\n    - Provided paths override the strategy only at that location.\n\nNotes\n-----\nThis request does **not** include documents; documents are retrieved\nfrom the session identified in the route."},"DiffResponse":{"properties":{"root":{"$ref":"#/components/schemas/DiffNode"}},"additionalProperties":false,"type":"object","required":["root"],"title":"DiffResponse","description":"Response payload containing the computed diff tree.\n\nAttributes\n----------\nroot : DiffNode\n    Root of the hierarchical diff tree.\n    The root node has:\n    - ``path == \"\"``\n    - ``key is None``\n\nNotes\n-----\nThe returned tree contains stable paths that the client can use for:\n- rendering side-by-side comparisons\n- driving merge selections\n- requesting array key suggestions"},"DiffStatus":{"type":"string","enum":["same","diff","missing","type_error"],"title":"DiffStatus","description":"Diff status for a node.\n\nAttributes\n----------\nsame : str\n    All documents that contain this node agree on the value, and no document\n    is missing the node.\ndiff : str\n    At least two documents contain this node but disagree on its value.\n    All present values share the same JSON type.\nmissing : str\n    At least one document is missing this node/path, but all documents that\n    contain it agree on its value.\n    Missingness is tracked separately from JSON null:\n    - missing means the key/path does not exist\n    - null means it exists and the value is JSON null\ntype_error : str\n    A structural/type-level issue prevents a meaningful value diff at this node.\n    Example scenarios:\n    - One document has an object while another has a string at the same path.\n    - An array strategy is invalid for the actual array contents (e.g. keyed\n      strategy but elements are not objects)."},"DocumentFormat":{"type":"string","enum":["json"],"title":"DocumentFormat","description":"Supported input document formats.\n\nAttributes\n----------\njson : str\n    JSON text input. This is currently the only supported format."},"DocumentMeta":{"properties":{"doc_id":{"type":"string","title":"Doc Id","description":"Stable id provided by client (e.g., uuid)."},"name":{"type":"string","title":"Name","description":"Display name shown in the UI."},"format":{"$ref":"#/components/schemas/DocumentFormat","description":"Declared document format.","default":"json"},"ok":{"type":"boolean","title":"Ok","description":"Whether the document parsed successfully."},"error":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Error","description":"Parse/validation error message when ok=False."}},"additionalProperties":false,"type":"object","required":["doc_id","name","ok"],"title":"DocumentMeta","description":"Lightweight document status for API responses.\n\nThis model is returned to clients to report whether each document\nwas successfully parsed and normalized.\n\nAttributes\n----------\nok : bool\n    Whether parsing and normalization succeeded.\nerror : str | None\n    Human-readable error message when ``ok=False``."},"ExportRequest":{"properties":{"merge_request":{"$ref":"#/components/schemas/MergeRequest","description":"Merge configuration reused during export."},"pretty":{"type":"boolean","title":"Pretty","default":true},"require_resolved":{"type":"boolean","title":"Require Resolved","default":false}},"additionalProperties":false,"type":"object","required":["merge_request"],"title":"ExportRequest","description":"Request payload for exporting the merged document.\n\nAttributes\n----------\nmerge_request : MergeRequest\n    Full merge configuration reused during export. This includes\n    array strategies and user selections.\n    Rationale:\n    Nesting the merge request ensures the frontend can reuse the\n    exact same state object across merge and export operations.\npretty : bool, default=True\n    Whether the exported text should be pretty-printed (indented).\n    If False, the output is compact.\nrequire_resolved : bool, default=False\n    If True, the export will fail when unresolved conflicts remain.\n    Behavior:\n    - False -> best-effort export with unresolved paths reported.\n    - True -> export endpoint should return a conflict error when\n      unresolved paths are present."},"ExportTextResponse":{"properties":{"unresolved_paths":{"items":{"type":"string"},"type":"array","title":"Unresolved Paths"},"text":{"type":"string","title":"Text"}},"additionalProperties":false,"type":"object","required":["text"],"title":"ExportTextResponse","description":"Response payload for text-based export.\n\nAttributes\n----------\ntext : str\n    Serialized merged document (typically JSON).\n\nunresolved_paths : list[str]\n    Canonical paths that remained unresolved during merge.\n    Interpretation:\n    - Empty list -> fully resolved export.\n    - Non-empty -> export was best-effort (unless strict mode\n      prevented it).\n\nNotes\n-----\nThis response is primarily intended for clipboard workflows. File\ndownloads typically use a binary response instead."},"HTTPValidationError":{"properties":{"detail":{"items":{"$ref":"#/components/schemas/ValidationError"},"type":"array","title":"Detail"}},"type":"object","title":"HTTPValidationError"},"InputDocument":{"properties":{"doc_id":{"type":"string","title":"Doc Id","description":"Stable id provided by client (e.g., uuid)."},"name":{"type":"string","title":"Name","description":"Display name shown in the UI."},"format":{"$ref":"#/components/schemas/DocumentFormat","description":"Declared document format.","default":"json"},"content":{"type":"string","title":"Content","description":"Raw document text."}},"additionalProperties":false,"type":"object","required":["doc_id","name","content"],"title":"InputDocument","description":"Client-supplied document payload.\n\nThis model represents the raw document submitted by the client for\noperations.\n\nAttributes\n----------\ncontent : str\n    Raw document text. Parsing and normalization are performed later\n    during session processing."},"KeySuggestion":{"properties":{"key":{"type":"string","title":"Key","description":"Object key name (e.g., 'id', 'name')."},"score":{"type":"number","title":"Score","description":"Overall heuristic score in [0, 1] (higher is better)."},"present_ratio":{"type":"number","title":"Present Ratio","description":"Fraction of object elements that contain this key."},"unique_ratio":{"type":"number","title":"Unique Ratio","description":"Average per-document uniqueness fraction for this key's values."},"scalar_ratio":{"type":"number","title":"Scalar Ratio","description":"Fraction of occurrences where the key's value is scalar-like."},"example_values":{"items":{"type":"string"},"type":"array","title":"Example Values","description":"Example observed values for this key (stringified)."}},"additionalProperties":false,"type":"object","required":["key","score","present_ratio","unique_ratio","scalar_ratio","example_values"],"title":"KeySuggestion","description":"Suggested candidate key for matching array elements.\n\nEach suggestion represents a heuristic evaluation of a field observed\nacross array elements. Higher scores indicate better suitability as a\nstable identifier for keyed array alignment.\n\nAttributes\n----------\nkey : str\n    Object key name (e.g., ``\"id\"``, ``\"name\"``).\nscore : float\n    Overall heuristic score in the range ``[0, 1]``. Higher is better.\npresent_ratio : float\n    Fraction of object elements that contain this key.\nunique_ratio : float\n    Average per-document uniqueness fraction of the key's values.\n    Higher values indicate better candidate identifier fields.\nscalar_ratio : float\n    Fraction of occurrences where the key's value is scalar-like\n    (string/number/boolean/null).\nexample_values : list[str]\n    Small sample of observed values for this key (stringified),\n    intended for UI preview only.\n\nNotes\n-----\n- Scores are heuristic and not guarantees of correctness.\n- The backend does not enforce that suggested keys are valid for keyed\n  array matching; validation occurs when the strategy is applied."},"MergeRequest":{"properties":{"diff_request":{"$ref":"#/components/schemas/DiffRequest","description":"Diff configuration reused during merge."},"selections":{"additionalProperties":{"$ref":"#/components/schemas/MergeSelection"},"type":"object","title":"Selections","description":"Map path -> selection (doc/manual)."}},"additionalProperties":false,"type":"object","required":["diff_request"],"title":"MergeRequest","description":"Request payload for computing a merged document.\n\nAttributes\n----------\ndiff_request : DiffRequest\n    Diff configuration reused during merge, primarily to supply\n    per-path array strategies.\n    Rationale:\n    Keeping this nested ensures the frontend can reuse the same\n    configuration object for both diff and merge operations.\nselections : dict[str, MergeSelection]\n    Mapping from canonical path -> user selection.\n    Semantics:\n    - Keys must match ``DiffNode.path`` values.\n    - Each selection determines which document (or manual value)\n      is chosen at that location.\n    - Selections inherit down the subtree unless overridden.\n\nNotes\n-----\nMissing selections for conflicting nodes will result in unresolved\npaths in the response."},"MergeResponse":{"properties":{"merged":{"title":"Merged"},"unresolved_paths":{"items":{"type":"string"},"type":"array","title":"Unresolved Paths"}},"additionalProperties":false,"type":"object","required":["merged"],"title":"MergeResponse","description":"Response payload containing the merged output.\n\nAttributes\n----------\nmerged : Any\n    The merged JSON-like structure produced after applying\n    selections. The structure matches the input document shape.\nunresolved_paths : list[str]\n    Canonical paths that could not be resolved due to missing\n    selections.\n    Behavior:\n    - Empty list -> merge fully resolved.\n    - Non-empty -> client should prompt the user for decisions.\n\nNotes\n-----\nThe backend performs a best-effort merge even when unresolved\nconflicts remain."},"MergeSelection":{"properties":{"kind":{"type":"string","enum":["doc","manual"],"title":"Kind","description":"Resolution mode: 'doc' or 'manual'."},"doc_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Doc Id","description":"Required when kind='doc'."},"manual_value":{"anyOf":[{},{"type":"null"}],"title":"Manual Value","description":"Required when kind='manual'."}},"additionalProperties":false,"type":"object","required":["kind"],"title":"MergeSelection","description":"User selection describing how to resolve a particular diff path.\n\nA selection specifies the source of truth for a node during merge.\nTwo modes are supported:\n- ``kind=\"doc\"``:\n    Select the value from a specific source document.\n- ``kind=\"manual\"``:\n    Override the value with a user-provided literal.\n\nSelections are applied hierarchically: a selection at path ``\"a.b\"``\napplies to all descendants (e.g., ``\"a.b.c\"``) unless a more specific\nselection overrides it.\n\nAttributes\n----------\nkind : {\"doc\", \"manual\"}\n    Resolution mode.\ndoc_id : str | None, default=None\n    Identifier of the source document when ``kind=\"doc\"``.\nmanual_value : Any | None, default=None\n    Literal value to inject when ``kind=\"manual\"``.\n\nNotes\n-----\n- Validation of whether the selected document actually contains the\n  requested path is performed during merge execution.\n- Manual values must be JSON-serializable for export operations."},"NodeKind":{"type":"string","enum":["scalar","object","array"],"title":"NodeKind","description":"Structural kind of a diff node.\n\nAttributes\n----------\nscalar : str\n    A JSON scalar leaf (string/number/boolean/null).\nobject : str\n    A JSON object.\narray : str\n    A JSON array."},"RemoveDocSessionRequest":{"properties":{"doc_id":{"type":"string","title":"Doc Id","description":"Document ID to remove from the session"}},"additionalProperties":false,"type":"object","required":["doc_id"],"title":"RemoveDocSessionRequest","description":"Request payload for removing a document from an existing session.\n\nAttributes\n----------\ndoc_id : str\n    Document ID to remove from the session. Document ID must correspond\n    to one previously added to the session.\n\nNotes\n-----\nRemoving documents updates the session state and may affect subsequent\ndiff and merge operations. Clients should ensure that removed document\nIDs are not referenced in future requests."},"SessionResponse":{"properties":{"session_id":{"type":"string","title":"Session Id"},"documents_meta":{"items":{"$ref":"#/components/schemas/DocumentMeta"},"type":"array","title":"Documents Meta"}},"additionalProperties":false,"type":"object","required":["session_id","documents_meta"],"title":"SessionResponse","description":"Response payload returned after creating a session.\n\nAttributes\n----------\nsession_id : str\n    Opaque identifier for the newly created session. Clients should\n    treat this as an opaque token and not infer semantics from its\n    contents.\ndocuments_meta : list[DocumentMeta]\n    Metadata describing the stored documents, including their\n    ``doc_id``, display name, declared format, and parse status.\n\nNotes\n-----\n- Session IDs may expire depending on server configuration (TTL).\n- Clients should persist the ``session_id`` for subsequent API calls."},"SuggestArrayKeysRequest":{"properties":{"path":{"type":"string","title":"Path","description":"Array node path (e.g. 'steps' or 'a.b[0].steps')."},"top_k":{"type":"integer","maximum":50.0,"minimum":-1.0,"title":"Top K","default":-1}},"additionalProperties":false,"type":"object","required":["path"],"title":"SuggestArrayKeysRequest","description":"Request payload for array key suggestion.\n\nAttributes\n----------\npath : str\n    Canonical path to the target array node (e.g., ``\"steps\"`` or\n    ``\"a.b[0].steps\"``). The path must resolve to an array in at least\n    one document.\ntop_k : int\n    Maximum number of suggestions to return.\n    Constraints:\n    - Minimum: -1 (no limit)\n    - Maximum: 50"},"SuggestArrayKeysResponse":{"properties":{"path":{"type":"string","title":"Path"},"suggestions":{"items":{"$ref":"#/components/schemas/KeySuggestion"},"type":"array","title":"Suggestions"}},"additionalProperties":false,"type":"object","required":["path","suggestions"],"title":"SuggestArrayKeysResponse","description":"Response payload containing ranked key suggestions.\n\nAttributes\n----------\npath : str\n    The array path that was analyzed. Echoed from the request for\n    convenience and client-side validation.\nsuggestions : list[KeySuggestion]\n    Ranked list of candidate keys, ordered by descending confidence\n    score. The list may be empty if no suitable keys were detected."},"ValidationError":{"properties":{"loc":{"items":{"anyOf":[{"type":"string"},{"type":"integer"}]},"type":"array","title":"Location"},"msg":{"type":"string","title":"Message"},"type":{"type":"string","title":"Error Type"},"input":{"title":"Input"},"ctx":{"type":"object","title":"Context"}},"type":"object","required":["loc","msg","type"],"title":"ValidationError"},"ValuePresence":{"properties":{"present":{"type":"boolean","title":"Present"},"value":{"anyOf":[{},{"type":"null"}],"title":"Value"},"value_type":{"anyOf":[{"type":"string","enum":["object","array","string","number","boolean","null"]},{"type":"null"}],"title":"Value Type","description":"Normalized JSON type label."}},"additionalProperties":false,"type":"object","required":["present"],"title":"ValuePresence","description":"Per-document presence/value information for a single node.\n\nThis structure answers: for a given diff node (identified by its canonical\npath), what does each document contain?\n\nAttributes\n----------\npresent : bool\n    Whether the node/path exists in the document.\n    - False means the key/path does not exist.\n    - True means the key/path exists (even if the value is JSON null).\nvalue : Any | None\n    The value at the node, when embedded in the response.\n    Interpretation rules:\n    - present=False always means \"missing\" regardless of `value`.\n    - present=True and value=None can mean either:\n      (a) the value is JSON null, or\n      (b) the backend intentionally omitted a container value (object/array)\n          to keep payloads small.\n          Use `value_type` and the node's `kind` to interpret `None` correctly.\nvalue_type : JsonType | None\n    Normalized JSON type label for the value.\n    - When present=False, this is typically None.\n    - When present=True, this is one of the JsonType literals.\n\nNotes\n-----\nImplementations commonly omit `value` for container nodes (object/array)."}}}}